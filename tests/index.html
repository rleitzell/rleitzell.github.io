<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Screenplay Analysis Tool - Tests</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .test-section {
            border: 1px solid #ddd;
            margin: 20px 0;
            padding: 20px;
            border-radius: 5px;
        }
        .test-pass {
            background-color: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }
        .test-fail {
            background-color: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }
        .test-pending {
            background-color: #fff3cd;
            border-color: #ffeaa7;
            color: #856404;
        }
        pre {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 3px;
            overflow-x: auto;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        .results {
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Screenplay Analysis Tool - Test Suite</h1>
    
    <div class="test-controls">
        <button onclick="runAllTests()">Run All Tests</button>
        <button onclick="runModelTests()">Test Models</button>
        <button onclick="runTextProcessorTests()">Test Text Processor</button>
        <button onclick="runSceneAnalyzerTests()">Test Scene Analyzer</button>
        <button onclick="runExportTests()">Test Export Utils</button>
        <button onclick="runPhase2Tests()">Test Phase 2 Features</button>
    </div>

    <div id="testResults"></div>

    <!-- Include the modules to test -->
    <script src="../js/models.js"></script>
    <script src="../js/textProcessor.js"></script>
    <script src="../js/sceneAnalyzer.js"></script>
    <script src="../js/exportUtils.js"></script>
    <script src="../js/phase2Manager.js"></script>

    <script>
        /**
         * Test framework
         */
        class TestFramework {
            constructor() {
                this.tests = [];
                this.results = [];
            }

            describe(name, testFunction) {
                const suite = {
                    name: name,
                    tests: [],
                    beforeEach: null,
                    afterEach: null
                };

                const context = {
                    it: (testName, testFn) => {
                        suite.tests.push({ name: testName, fn: testFn });
                    },
                    beforeEach: (fn) => {
                        suite.beforeEach = fn;
                    },
                    afterEach: (fn) => {
                        suite.afterEach = fn;
                    }
                };

                testFunction(context);
                this.tests.push(suite);
            }

            async runTests(suiteFilter = null) {
                this.results = [];
                const resultsDiv = document.getElementById('testResults');
                resultsDiv.innerHTML = '<h2>Running Tests...</h2>';

                for (const suite of this.tests) {
                    if (suiteFilter && !suite.name.includes(suiteFilter)) {
                        continue;
                    }

                    const suiteResults = {
                        name: suite.name,
                        tests: [],
                        passed: 0,
                        failed: 0
                    };

                    for (const test of suite.tests) {
                        let testResult = {
                            name: test.name,
                            status: 'pass',
                            error: null,
                            duration: 0
                        };

                        try {
                            if (suite.beforeEach) {
                                await suite.beforeEach();
                            }

                            const startTime = performance.now();
                            await test.fn();
                            const endTime = performance.now();
                            
                            testResult.duration = endTime - startTime;
                            suiteResults.passed++;

                            if (suite.afterEach) {
                                await suite.afterEach();
                            }
                        } catch (error) {
                            testResult.status = 'fail';
                            testResult.error = error.message;
                            suiteResults.failed++;
                        }

                        suiteResults.tests.push(testResult);
                    }

                    this.results.push(suiteResults);
                }

                this.displayResults();
            }

            displayResults() {
                const resultsDiv = document.getElementById('testResults');
                let html = '<h2>Test Results</h2>';

                let totalPassed = 0;
                let totalFailed = 0;

                for (const suite of this.results) {
                    totalPassed += suite.passed;
                    totalFailed += suite.failed;

                    const suiteClass = suite.failed > 0 ? 'test-fail' : 'test-pass';
                    html += `
                        <div class="test-section ${suiteClass}">
                            <h3>${suite.name}</h3>
                            <p>Passed: ${suite.passed}, Failed: ${suite.failed}</p>
                    `;

                    for (const test of suite.tests) {
                        const status = test.status === 'pass' ? '✓' : '✗';
                        const duration = test.duration.toFixed(2);
                        html += `
                            <div style="margin: 10px 0;">
                                <strong>${status} ${test.name}</strong> (${duration}ms)
                                ${test.error ? `<br><span style="color: red;">Error: ${test.error}</span>` : ''}
                            </div>
                        `;
                    }

                    html += '</div>';
                }

                html += `
                    <div class="test-section ${totalFailed > 0 ? 'test-fail' : 'test-pass'}">
                        <h3>Summary</h3>
                        <p><strong>Total Passed:</strong> ${totalPassed}</p>
                        <p><strong>Total Failed:</strong> ${totalFailed}</p>
                        <p><strong>Success Rate:</strong> ${((totalPassed / (totalPassed + totalFailed)) * 100).toFixed(1)}%</p>
                    </div>
                `;

                resultsDiv.innerHTML = html;
            }
        }

        // Assertion helpers
        function expect(actual) {
            return {
                toBe: (expected) => {
                    if (actual !== expected) {
                        throw new Error(`Expected ${actual} to be ${expected}`);
                    }
                },
                toEqual: (expected) => {
                    if (JSON.stringify(actual) !== JSON.stringify(expected)) {
                        throw new Error(`Expected ${JSON.stringify(actual)} to equal ${JSON.stringify(expected)}`);
                    }
                },
                toContain: (expected) => {
                    if (!actual.includes(expected)) {
                        throw new Error(`Expected ${actual} to contain ${expected}`);
                    }
                },
                toBeGreaterThan: (expected) => {
                    if (actual <= expected) {
                        throw new Error(`Expected ${actual} to be greater than ${expected}`);
                    }
                },
                toBeTruthy: () => {
                    if (!actual) {
                        throw new Error(`Expected ${actual} to be truthy`);
                    }
                },
                toBeFalsy: () => {
                    if (actual) {
                        throw new Error(`Expected ${actual} to be falsy`);
                    }
                }
            };
        }

        // Initialize test framework
        const testFramework = new TestFramework();

        /**
         * Model Tests
         */
        testFramework.describe('Scene Model', ({ it }) => {
            it('should create a scene with default values', () => {
                const scene = new Scene();
                expect(scene.id).toBe(null);
                expect(scene.number).toBe(null);
                expect(scene.slugline).toBe('');
                expect(scene.location).toBe('');
                expect(scene.timeOfDay).toBe('');
                expect(scene.content).toBe('');
                expect(scene.characters).toEqual([]);
                expect(scene.estimatedLength).toBe(0);
            });

            it('should generate deterministic scene ID', () => {
                const scene = new Scene({
                    number: 1,
                    location: 'KITCHEN',
                    timeOfDay: 'DAY'
                });
                const id1 = scene.generateId();
                const id2 = scene.generateId();
                expect(id1).toBe(id2);
                expect(id1).toBeTruthy();
            });

            it('should parse slugline correctly', () => {
                const scene = new Scene({
                    slugline: 'INT. KITCHEN - DAY'
                });
                scene.parseSlugline();
                expect(scene.location).toBe('KITCHEN');
                expect(scene.timeOfDay).toBe('DAY');
            });

            it('should normalize time of day', () => {
                const scene = new Scene();
                expect(scene.normalizeTimeOfDay('day')).toBe('DAY');
                expect(scene.normalizeTimeOfDay('NIGHT')).toBe('NIGHT');
                expect(scene.normalizeTimeOfDay('continuous')).toBe('CONTINUOUS');
            });

            it('should extract characters from content', () => {
                const scene = new Scene({
                    content: `JOHN
Hello there!

JANE
Hi John, how are you?

JOHN
I'm doing well, thanks.`
                });
                scene.extractCharacters();
                expect(scene.characters).toContain('JOHN');
                expect(scene.characters).toContain('JANE');
                expect(scene.characters.length).toBe(2);
            });

            it('should estimate scene length', () => {
                const scene = new Scene({
                    content: 'This is a short scene with just a few words.'
                });
                scene.estimateLength();
                expect(scene.estimatedLength).toBeGreaterThan(0);
            });
        });

        testFramework.describe('Character Model', ({ it }) => {
            it('should create character with name', () => {
                const character = new Character('JOHN');
                expect(character.name).toBe('JOHN');
                expect(character.scenes).toEqual([]);
                expect(character.totalAppearances).toBe(0);
            });

            it('should add scene and increment appearances', () => {
                const character = new Character('JOHN');
                character.addScene('scene1');
                character.addScene('scene2');
                expect(character.scenes).toContain('scene1');
                expect(character.scenes).toContain('scene2');
                expect(character.totalAppearances).toBe(2);
            });

            it('should not add duplicate scenes', () => {
                const character = new Character('JOHN');
                character.addScene('scene1');
                character.addScene('scene1');
                expect(character.scenes.length).toBe(1);
                expect(character.totalAppearances).toBe(1);
            });
        });

        /**
         * Text Processor Tests
         */
        testFramework.describe('Text Processor', ({ it }) => {
            let textProcessor;

            it('should create text processor instance', () => {
                textProcessor = new TextProcessor();
                expect(textProcessor).toBeTruthy();
                expect(textProcessor.sceneBreakPatterns.length).toBeGreaterThan(0);
            });

            it('should identify scene breaks', () => {
                textProcessor = new TextProcessor();
                expect(textProcessor.isSceneBreak('INT. KITCHEN - DAY')).toBeTruthy();
                expect(textProcessor.isSceneBreak('EXT. GARDEN - NIGHT')).toBeTruthy();
                expect(textProcessor.isSceneBreak('Regular dialogue line')).toBeFalsy();
            });

            it('should clean text properly', () => {
                textProcessor = new TextProcessor();
                const dirtyText = '  This   has   extra   spaces  \n\n\n  and   newlines  ';
                const cleanText = textProcessor.cleanText(dirtyText);
                expect(cleanText).toBe('This has extra spaces and newlines');
            });

            it('should process text and extract scenes', () => {
                textProcessor = new TextProcessor();
                const sampleText = `
INT. KITCHEN - DAY

JOHN enters the kitchen.

JOHN
Good morning!

INT. LIVING ROOM - DAY

JANE is reading a book.

JANE
Hello there.
                `;
                
                const scenes = textProcessor.processText(sampleText);
                expect(scenes.length).toBe(2);
                expect(scenes[0].location).toBe('KITCHEN');
                expect(scenes[1].location).toBe('LIVING ROOM');
            });

            it('should chunk text appropriately', () => {
                textProcessor = new TextProcessor();
                const longText = 'a'.repeat(10000);
                const chunks = textProcessor.chunkText(longText, 5000);
                expect(chunks.length).toBeGreaterThan(1);
                expect(chunks[0].length).toBe(5000);
                
                // Test short text doesn't get chunked
                const shortText = 'short text';
                const shortChunks = textProcessor.chunkText(shortText, 5000);
                expect(shortChunks.length).toBe(1);
                expect(shortChunks[0]).toBe(shortText);
            });
        });

        /**
         * Scene Analyzer Tests
         */
        testFramework.describe('Scene Analyzer', ({ it }) => {
            let sceneAnalyzer;

            it('should create scene analyzer instance', () => {
                sceneAnalyzer = new SceneAnalyzer();
                expect(sceneAnalyzer).toBeTruthy();
                expect(sceneAnalyzer.scenes).toEqual([]);
            });

            it('should analyze text and return results', async () => {
                sceneAnalyzer = new SceneAnalyzer();
                const extractedData = {
                    text: `
INT. KITCHEN - DAY

JOHN
Good morning!

JANE
Hello!

EXT. GARDEN - NIGHT

JOHN
Nice evening.
                    `
                };

                const results = await sceneAnalyzer.analyzeText(extractedData);
                expect(results.scenes.length).toBe(2);
                expect(results.characters.length).toBeGreaterThan(0);
                expect(results.locations.length).toBeGreaterThan(0);
                expect(results.summary).toBeTruthy();
            });
        });

        /**
         * Export Utils Tests
         */
        testFramework.describe('Export Utils', ({ it }) => {
            let exportUtils;

            it('should create export utils instance', () => {
                exportUtils = new ExportUtils();
                expect(exportUtils).toBeTruthy();
                expect(exportUtils.formats).toContain('csv');
                expect(exportUtils.formats).toContain('json');
            });

            it('should escape CSV values correctly', () => {
                exportUtils = new ExportUtils();
                expect(exportUtils.escapeCsvValue('simple')).toBe('simple');
                expect(exportUtils.escapeCsvValue('has, comma')).toBe('"has, comma"');
                expect(exportUtils.escapeCsvValue('has "quote"')).toBe('"has ""quote"""');
            });

            it('should export scenes to CSV', () => {
                exportUtils = new ExportUtils();
                const scenes = [
                    new Scene({
                        number: 1,
                        location: 'KITCHEN',
                        timeOfDay: 'DAY',
                        slugline: 'INT. KITCHEN - DAY',
                        characters: ['JOHN', 'JANE'],
                        estimatedLength: 2,
                        content: 'A simple scene'
                    })
                ];

                const csv = exportUtils.exportScenesCSV(scenes);
                expect(csv).toContain('Scene Number');
                expect(csv).toContain('KITCHEN');
                expect(csv).toContain('JOHN; JANE');
            });

            it('should generate filename with timestamp', () => {
                exportUtils = new ExportUtils();
                const filename = exportUtils.generateFilename('test', 'csv');
                expect(filename).toContain('test_');
                expect(filename).toContain('.csv');
            });
        });

        /**
         * Phase 2 Manager Tests
         */
        testFramework.describe('Phase 2 Manager', ({ it, beforeEach, afterEach }) => {
            let phase2Manager;
            let mockApp;
            let testScenes;

            beforeEach(() => {
                // Create mock app with analysis data
                testScenes = [
                    new Scene({
                        number: 1,
                        location: 'KITCHEN',
                        timeOfDay: 'DAY',
                        slugline: 'INT. KITCHEN - DAY',
                        characters: ['JOHN', 'JANE'],
                        estimatedLength: 2,
                        content: 'JOHN\nHello!\n\nJANE\nHi there!'
                    }),
                    new Scene({
                        number: 1, // Duplicate number
                        location: 'LIVING ROOM',
                        timeOfDay: 'NIGHT',
                        slugline: 'INT. LIVING ROOM - NIGHT',
                        characters: ['JANE', 'BOB'],
                        estimatedLength: 3,
                        content: 'JANE\nGoodnight!\n\nBOB\nSee you tomorrow!'
                    }),
                    new Scene({
                        number: 2,
                        location: 'KITCHEN',
                        timeOfDay: 'MORNING',
                        slugline: 'INT. KITCHEN - MORNING',
                        characters: ['JOHN'],
                        estimatedLength: 1,
                        content: 'JOHN\nCoffee time!'
                    })
                ];

                // Generate IDs for scenes
                testScenes.forEach(scene => scene.id = scene.generateId());

                mockApp = {
                    currentAnalysis: {
                        scenes: testScenes,
                        characters: [
                            new Character('JOHN'),
                            new Character('JANE'),
                            new Character('BOB')
                        ],
                        locations: [
                            { name: 'KITCHEN', scenes: [], totalUses: 2 },
                            { name: 'LIVING ROOM', scenes: [], totalUses: 1 }
                        ]
                    },
                    sceneAnalyzer: {
                        updateAnalysisData: (data) => {
                            // Mock implementation
                            return data;
                        }
                    },
                    displayResults: () => {
                        // Mock implementation
                    },
                    displayScenes: () => {
                        // Mock implementation
                    }
                };

                // Create DOM elements that Phase2Manager expects
                if (!document.getElementById('resultsSection')) {
                    const resultsSection = document.createElement('div');
                    resultsSection.id = 'resultsSection';
                    resultsSection.innerHTML = `
                        <div class="results-tabs"></div>
                    `;
                    document.body.appendChild(resultsSection);
                }

                phase2Manager = new Phase2Manager(mockApp);
            });

            afterEach(() => {
                // Clean up DOM
                const resultsSection = document.getElementById('resultsSection');
                if (resultsSection) {
                    resultsSection.remove();
                }
                const modals = document.querySelectorAll('.modal-overlay');
                modals.forEach(modal => modal.remove());
            });

            it('should create phase2 manager instance', () => {
                expect(phase2Manager).toBeTruthy();
                expect(phase2Manager.app).toBe(mockApp);
                expect(phase2Manager.isEditMode).toBe(false);
                expect(phase2Manager.selectedScenes).toBeTruthy();
                expect(phase2Manager.characterMappings).toBeTruthy();
                expect(phase2Manager.locationMappings).toBeTruthy();
            });

            it('should initialize edit controls', () => {
                const editControls = document.querySelector('.edit-controls');
                expect(editControls).toBeTruthy();
                
                const editModeToggle = document.getElementById('editModeToggle');
                expect(editModeToggle).toBeTruthy();
                expect(editModeToggle.textContent).toContain('Enable Edit Mode');
            });

            it('should toggle edit mode', () => {
                expect(phase2Manager.isEditMode).toBe(false);
                
                phase2Manager.toggleEditMode();
                expect(phase2Manager.isEditMode).toBe(true);
                
                const toggleBtn = document.getElementById('editModeToggle');
                expect(toggleBtn.textContent).toContain('View Mode');
                
                phase2Manager.toggleEditMode();
                expect(phase2Manager.isEditMode).toBe(false);
            });

            it('should detect duplicate scene numbers', () => {
                const scene1 = testScenes[0]; // Scene number 1
                const scene2 = testScenes[1]; // Scene number 1 (duplicate)
                const scene3 = testScenes[2]; // Scene number 2
                
                expect(phase2Manager.isDuplicateSceneNumber(scene1)).toBe(true);
                expect(phase2Manager.isDuplicateSceneNumber(scene2)).toBe(true);
                expect(phase2Manager.isDuplicateSceneNumber(scene3)).toBe(false);
            });

            it('should find duplicate scenes', () => {
                const duplicates = phase2Manager.findDuplicateScenes();
                expect(duplicates.length).toBe(1);
                expect(duplicates[0].number).toBe(1);
                expect(duplicates[0].scenes.length).toBe(2);
            });

            it('should handle scene selection', () => {
                phase2Manager.toggleSceneSelection(0, true);
                expect(phase2Manager.selectedScenes.has(0)).toBe(true);
                
                phase2Manager.toggleSceneSelection(1, true);
                expect(phase2Manager.selectedScenes.has(1)).toBe(true);
                expect(phase2Manager.selectedScenes.size).toBe(2);
                
                phase2Manager.toggleSceneSelection(0, false);
                expect(phase2Manager.selectedScenes.has(0)).toBe(false);
                expect(phase2Manager.selectedScenes.size).toBe(1);
            });

            it('should create modal dialog', () => {
                const modal = phase2Manager.createModal('Test Title', '<p>Test content</p>');
                expect(modal).toBeTruthy();
                expect(modal.className).toBe('modal-overlay');
                expect(modal.innerHTML).toContain('Test Title');
                expect(modal.innerHTML).toContain('Test content');
            });

            it('should auto-resolve conflicts', () => {
                const originalNumbers = testScenes.map(s => s.number);
                expect(originalNumbers).toEqual([1, 1, 2]); // Has duplicates
                
                phase2Manager.autoResolveConflicts();
                
                const newNumbers = testScenes.map(s => s.number);
                expect(newNumbers).toEqual([1, 2, 3]); // No duplicates
            });
        });

        testFramework.describe('Phase 2 Scene Updates', ({ it, beforeEach }) => {
            let sceneAnalyzer;
            let testData;

            beforeEach(() => {
                sceneAnalyzer = new SceneAnalyzer();
                testData = {
                    scenes: [
                        new Scene({
                            number: 1,
                            location: 'KITCHEN',
                            timeOfDay: 'DAY',
                            characters: ['JOHN'],
                            content: 'Test content'
                        })
                    ],
                    characters: [],
                    locations: [],
                    summary: {}
                };
                testData.scenes[0].id = testData.scenes[0].generateId();
            });

            it('should update analysis data after scene modifications', () => {
                // Modify scene
                testData.scenes[0].location = 'LIVING ROOM';
                testData.scenes[0].characters = ['JOHN', 'JANE'];
                
                sceneAnalyzer.updateAnalysisData(testData);
                
                expect(testData.characters.length).toBeGreaterThan(0);
                expect(testData.locations.length).toBeGreaterThan(0);
                expect(testData.summary).toBeTruthy();
            });

            it('should handle invalid analysis data gracefully', () => {
                // Test with null data
                let errorThrown = false;
                try {
                    sceneAnalyzer.updateAnalysisData(null);
                } catch (error) {
                    errorThrown = true;
                }
                expect(errorThrown).toBeFalsy();

                // Test with missing scenes
                errorThrown = false;
                try {
                    sceneAnalyzer.updateAnalysisData({});
                } catch (error) {
                    errorThrown = true;
                }
                expect(errorThrown).toBeFalsy();
            });
        });

        testFramework.describe('Phase 2 UI Integration', ({ it, beforeEach, afterEach }) => {
            let container;

            beforeEach(() => {
                container = document.createElement('div');
                container.innerHTML = `
                    <div id="resultsSection" style="display: block;">
                        <div class="results-tabs"></div>
                        <div id="scenesList">
                            <div class="scene-item">
                                <div class="scene-header">
                                    <span class="scene-number">Scene 1</span>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                document.body.appendChild(container);
            });

            afterEach(() => {
                container.remove();
                const modals = document.querySelectorAll('.modal-overlay');
                modals.forEach(modal => modal.remove());
            });

            it('should add edit controls to results section', () => {
                const mockApp = {
                    currentAnalysis: { scenes: [], characters: [], locations: [] },
                    sceneAnalyzer: { updateAnalysisData: () => {} },
                    displayResults: () => {}
                };

                new Phase2Manager(mockApp);
                
                const editControls = document.querySelector('.edit-controls');
                expect(editControls).toBeTruthy();
                
                const toggleButton = document.getElementById('editModeToggle');
                expect(toggleButton).toBeTruthy();
            });

            it('should create scene editor form with all required fields', () => {
                const mockApp = {
                    currentAnalysis: {
                        scenes: [new Scene({
                            number: 1,
                            location: 'TEST LOCATION',
                            timeOfDay: 'DAY',
                            slugline: 'INT. TEST LOCATION - DAY',
                            characters: ['TEST CHARACTER'],
                            estimatedLength: 2,
                            content: 'Test content'
                        })],
                        characters: [],
                        locations: []
                    },
                    sceneAnalyzer: { updateAnalysisData: () => {} },
                    displayResults: () => {}
                };

                const phase2Manager = new Phase2Manager(mockApp);
                phase2Manager.openSceneEditor(0);
                
                // Check modal was created
                const modal = document.querySelector('.modal-overlay');
                expect(modal).toBeTruthy();
                
                // Check form fields exist
                expect(document.getElementById('sceneNumber')).toBeTruthy();
                expect(document.getElementById('sceneSlugline')).toBeTruthy();
                expect(document.getElementById('sceneLocation')).toBeTruthy();
                expect(document.getElementById('sceneTimeOfDay')).toBeTruthy();
                expect(document.getElementById('sceneCharacters')).toBeTruthy();
                expect(document.getElementById('sceneLength')).toBeTruthy();
                expect(document.getElementById('sceneContent')).toBeTruthy();
            });
        });

        /**
         * Test control functions
         */
        function runAllTests() {
            testFramework.runTests();
        }

        function runModelTests() {
            testFramework.runTests('Model');
        }

        function runTextProcessorTests() {
            testFramework.runTests('Text Processor');
        }

        function runSceneAnalyzerTests() {
            testFramework.runTests('Scene Analyzer');
        }

        function runExportTests() {
            testFramework.runTests('Export Utils');
        }

        function runPhase2Tests() {
            testFramework.runTests('Phase 2');
        }

        // Auto-run tests on page load
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Test page loaded. Click "Run All Tests" to start testing.');
        });
    </script>
</body>
</html>